/*
SpaceTraders API

SpaceTraders is an open-universe game and learning platform that offers a set of HTTP endpoints to control a fleet of ships and explore a multiplayer universe.  The API is documented using [OpenAPI](https://github.com/SpaceTradersAPI/api-docs). You can send your first request right here in your browser to check the status of the game server.  ```json http {   \"method\": \"GET\",   \"url\": \"https://api.spacetraders.io/v2\", } ```  Unlike a traditional game, SpaceTraders does not have a first-party client or app to play the game. Instead, you can use the API to build your own client, write a script to automate your ships, or try an app built by the community.  We have a [Discord channel](https://discord.com/invite/jh6zurdWk5) where you can share your projects, ask questions, and get help from other players.

API version: 2.0.0
Contact: joel@spacetraders.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
	"time"
)

// checks if the Survey type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &Survey{}

// Survey A resource survey of a waypoint, detailing a specific extraction location and the types of resources that can be found there.
type Survey struct {
	// A unique signature for the location of this survey. This signature is verified when attempting an extraction using this survey.
	Signature string `json:"signature"`
	// The symbol of the waypoint that this survey is for.
	Symbol string `json:"symbol"`
	// A list of deposits that can be found at this location. A ship will extract one of these deposits when using this survey in an extraction request. If multiple deposits of the same type are present, the chance of extracting that deposit is increased.
	Deposits []SurveyDeposit `json:"deposits"`
	// The date and time when the survey expires. After this date and time, the survey will no longer be available for extraction.
	Expiration time.Time `json:"expiration"`
	// The size of the deposit. This value indicates how much can be extracted from the survey before it is exhausted.
	Size                 string `json:"size"`
	AdditionalProperties map[string]interface{}
}

type _Survey Survey

// NewSurvey instantiates a new Survey object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewSurvey(signature string, symbol string, deposits []SurveyDeposit, expiration time.Time, size string) *Survey {
	this := Survey{}
	this.Signature = signature
	this.Symbol = symbol
	this.Deposits = deposits
	this.Expiration = expiration
	this.Size = size
	return &this
}

// NewSurveyWithDefaults instantiates a new Survey object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewSurveyWithDefaults() *Survey {
	this := Survey{}
	return &this
}

// GetSignature returns the Signature field value
func (o *Survey) GetSignature() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Signature
}

// GetSignatureOk returns a tuple with the Signature field value
// and a boolean to check if the value has been set.
func (o *Survey) GetSignatureOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Signature, true
}

// SetSignature sets field value
func (o *Survey) SetSignature(v string) {
	o.Signature = v
}

// GetSymbol returns the Symbol field value
func (o *Survey) GetSymbol() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Symbol
}

// GetSymbolOk returns a tuple with the Symbol field value
// and a boolean to check if the value has been set.
func (o *Survey) GetSymbolOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Symbol, true
}

// SetSymbol sets field value
func (o *Survey) SetSymbol(v string) {
	o.Symbol = v
}

// GetDeposits returns the Deposits field value
func (o *Survey) GetDeposits() []SurveyDeposit {
	if o == nil {
		var ret []SurveyDeposit
		return ret
	}

	return o.Deposits
}

// GetDepositsOk returns a tuple with the Deposits field value
// and a boolean to check if the value has been set.
func (o *Survey) GetDepositsOk() ([]SurveyDeposit, bool) {
	if o == nil {
		return nil, false
	}
	return o.Deposits, true
}

// SetDeposits sets field value
func (o *Survey) SetDeposits(v []SurveyDeposit) {
	o.Deposits = v
}

// GetExpiration returns the Expiration field value
func (o *Survey) GetExpiration() time.Time {
	if o == nil {
		var ret time.Time
		return ret
	}

	return o.Expiration
}

// GetExpirationOk returns a tuple with the Expiration field value
// and a boolean to check if the value has been set.
func (o *Survey) GetExpirationOk() (*time.Time, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Expiration, true
}

// SetExpiration sets field value
func (o *Survey) SetExpiration(v time.Time) {
	o.Expiration = v
}

// GetSize returns the Size field value
func (o *Survey) GetSize() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Size
}

// GetSizeOk returns a tuple with the Size field value
// and a boolean to check if the value has been set.
func (o *Survey) GetSizeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Size, true
}

// SetSize sets field value
func (o *Survey) SetSize(v string) {
	o.Size = v
}

func (o Survey) MarshalJSON() ([]byte, error) {
	toSerialize, err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o Survey) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["signature"] = o.Signature
	toSerialize["symbol"] = o.Symbol
	toSerialize["deposits"] = o.Deposits
	toSerialize["expiration"] = o.Expiration
	toSerialize["size"] = o.Size

	for key, value := range o.AdditionalProperties {
		toSerialize[key] = value
	}

	return toSerialize, nil
}

func (o *Survey) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"signature",
		"symbol",
		"deposits",
		"expiration",
		"size",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err
	}

	for _, requiredProperty := range requiredProperties {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varSurvey := _Survey{}

	err = json.Unmarshal(data, &varSurvey)

	if err != nil {
		return err
	}

	*o = Survey(varSurvey)

	additionalProperties := make(map[string]interface{})

	if err = json.Unmarshal(data, &additionalProperties); err == nil {
		delete(additionalProperties, "signature")
		delete(additionalProperties, "symbol")
		delete(additionalProperties, "deposits")
		delete(additionalProperties, "expiration")
		delete(additionalProperties, "size")
		o.AdditionalProperties = additionalProperties
	}

	return err
}

type NullableSurvey struct {
	value *Survey
	isSet bool
}

func (v NullableSurvey) Get() *Survey {
	return v.value
}

func (v *NullableSurvey) Set(val *Survey) {
	v.value = val
	v.isSet = true
}

func (v NullableSurvey) IsSet() bool {
	return v.isSet
}

func (v *NullableSurvey) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableSurvey(val *Survey) *NullableSurvey {
	return &NullableSurvey{value: val, isSet: true}
}

func (v NullableSurvey) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableSurvey) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
